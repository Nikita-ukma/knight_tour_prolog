% Розмір дошки
size(8, 8).

% Можливі ходи коня
move(X, Y, NX, NY) :-
    member((DX, DY), [(-2,-1), (-2,1), (2,-1), (2,1), (-1,-2), (-1,2), (1,-2), (1,2)]),
    NX is X + DX,
    NY is Y + DY,
    size(W, H),
    NX >= 0, NX < W,
    NY >= 0, NY < H.

% Перевіряє, чи всі клітини відвідані
knight_tour(_, _, Board, Path, Path) :- length(Board, Size), length(Path, Size).

% Основний рекурсивний алгоритм обходу
knight_tour(X, Y, Board, Path, Result) :-
    move(X, Y, NX, NY),
    \+ member((NX, NY), Path),  % Перевірка, чи клітина ще не відвідана
    knight_tour(NX, NY, Board, [(NX, NY)|Path], Result).

% Виклик обходу з початкової позиції
solve_knight_tour(X, Y, Path) :-
    size(W, H),
    Total is W * H,
    knight_tour(X, Y, Total, [(X, Y)], Path).
4. Порівняння продуктивності
Python: Реалізація на Python дозволяє контролювати оптимізацію, наприклад, додавати сортування можливих ходів для швидшого пошуку розв’язку.
Prolog: Логічне виведення може бути менш ефективним через великий простір пошуку, якщо не використовувати евристику (наприклад, впорядкування можливих ходів).
5. Застосування
Python: Підходить для реальних застосувань, оскільки його простіше оптимізувати і інтегрувати в більші проєкти.
Prolog: Більш придатний для демонстрації логічного підходу або для використання в автоматичних доведеннях і штучному інтелекті.
Висновок:
Якщо потрібна оптимізована, ефективна реалізація, Python буде кращим вибором.
Якщо завдання формулюється як логічна проблема, яку можна описати за допомогою правил, Prolog забезпечує більш елегантний підхід.
Хочеш, щоб я додав код для вимірювання часу роботи у версії на Prolog?






Вы сказали:
А можеш запропонувати іншу реалізацію цього завдання на пролозі, без використання бектрекінгу?
ChatGPT сказал:
Так, можливо реалізувати обхід конем без використання бектрекінгу, наприклад, використовуючи ітеративний підхід із чергою або методом гібридного жадібного пошуку.

Жадібний алгоритм Варнсдорфа без бектрекінгу в Prolog
Цей алгоритм на кожному кроці вибирає наступний хід коня, керуючись евристикою — вибирає клітинку, з якої є найменше наступних можливих ходів.

prolog
Копировать
Редактировать
% Розмір шахівниці
size(8, 8).

% Визначення всіх можливих ходів коня
move(X, Y, NX, NY) :-
    member((DX, DY), [(-2,-1), (-2,1), (2,-1), (2,1), (-1,-2), (-1,2), (1,-2), (1,2)]),
    NX is X + DX,
    NY is Y + DY,
    size(W, H),
    NX >= 0, NX < W,
    NY >= 0, NY < H.

% Рахує кількість доступних ходів з даної клітинки
count_moves(X, Y, Count) :-
    findall((NX, NY), (move(X, Y, NX, NY)), Moves),
    length(Moves, Count).

% Сортування можливих ходів за кількістю доступних наступних ходів
sorted_moves(X, Y, Sorted) :-
    findall((NX, NY, C), (move(X, Y, NX, NY), count_moves(NX, NY, C)), Moves),
    sort(3, @=<, Moves, Sorted).

% Основна функція обходу дошки
knight_tour(_, _, Path, Path, 64) :- !.  % Якщо всі 64 клітини відвідано – завершити

knight_tour(X, Y, Visited, Path, MoveCount) :-
    sorted_moves(X, Y, Moves),
    member((NX, NY, _), Moves),  % Вибираємо хід з найменшим числом можливих наступних ходів
    \+ member((NX, NY), Visited),  % Уникнення повторень
    NewMoveCount is MoveCount + 1,
    knight_tour(NX, NY, [(NX, NY) | Visited], Path, NewMoveCount).

% Виклик обходу з початкової позиції
solve_knight_tour(X, Y, Path) :-
    knight_tour(X, Y, [(X, Y)], Path, 1).
